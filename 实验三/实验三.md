# <center>实验三、传输层TCP协议分析实验报告<center>

| 组号： | 3-3-1  |        |            |        |          |
| ------ | ------ | ------ | ---------- | ------ | -------- |
| 姓名： | 李云广 | 学号： | 2193712575 | 班级： | 计算机93 |
| 姓名： | 李怀邦 | 学号： | 2193712530 | 班级： | 计算机93 |

## 一、 实验目的

1. 理解TCP报文首部格式和字段的作用，TCP连接的建立和释放过程，TCP数据传输中的编号与确认的过程。

2. 理解TCP的错误恢复的工作原理和字节流的传输模式，分析错误恢复机制中TCP双方的交互情况。

3. 理解TCP的流量控制的工作原理，分析流量控制中TCP双方的交互情况。

4. 理解TCP的拥塞控制的工作原理，分析拥塞控制中TCP双方的交互情况。

## 二、 实验内容

1. 使用基于TCP的应用程序（如浏览器下载文件）传输文件，**在客户端和服务器均要捕获TCP报文。**

2. 分析TCP报文首部信息、TCP连接的建立和释放过程、TCP数据的编号与确认机制。观察几个典型的TCP选项：MSS、SACK、Window Scale、Timestamp等，查资料说明其用途。

3. 观察和估计客户机到服务器的RTT，双方各自的MSS，计算丢包率及重传的流量。

4. 观察TCP的流量控制过程，和拥塞控制中的慢启动、快速重传、拥塞避免，快速恢复等过程【观察拥塞控制的难度较大，观察到两个过程即可】。

![img](C:/Users/dell/AppData/Local/Temp/ksohtml/wps8332.tmp.jpg)

图4-0 典型的TCP 拥塞控制过程图例

5. *（可选）注意观察初始的cwnd是多少，看看不同的操作系统初始cwnd的差别。观察有没有Delay ACK的应答模式，注意不同操作系统的差异。

【可以增加题目规定以外的分析】

## 三、 实验环境与分组

1）云服务器一台，启动Apache2服务（或其他服务器程序）。

2）每2名同学一组，各自在电脑上运行客户端程序（浏览器或其他客户端程序）。

3）使用客户端程序下载数据，运行Wireshark软件捕获报文。【注意：可以关闭Wireshark的HTTP协议分析，专注在TCP协议上，关闭方法是：菜单‘分析’—>‘启用的协议’中，取消‘HTTP’的选择。】

## 四、 实验组网

下图是本实验的组网图，图中参数请根据实际情况标注。

![image-20220318185301759](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220318185301759.png)

 

## 五、 实验过程及结果分析

【过程记录应当详尽，截图并加以说明。以下过程和表格仅供参考。】

### 步骤1：

PC2通过ssh登录到服务器Z上，在云服务器上启动合适的服务器程序。

### 步骤2：

在PC1和Z上启动报文捕获软件，开始截获报文【注意加过滤器，比如host w.x.y.z；不熟悉tcpdump的可以用 tcpdump -n -s 500 tcp and host A.B.C.D and port P -w server.pcap选项，把报文记录到文件中，传输到客户端用Wireshark分析。其中A.B.C.D是客户端的**公网地址**，**P是服务端口，如80**】。

### 步骤3：

在PC1上运行客户端软件，发送和接收一个约500KB的文件。文件传输完成后，停止报文截获。

### 步骤4：

对比观察客户端和服务器截获的报文，分析TCP协议的建立过程的三个报文并填写表3-1。分析TCP连接的释放过程，选择TCP连接撤销的四个报文并填写表3-2。 

PC1在服务器端输入：

```
tcpdump -n -s 500 tcp -w server.pcap
```

在客户端PC2也启动wireshark抓包，立即使用xftp连接向服务器发送大约500kb的文件。

![image-20220314093339863](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314093339863.png)

表3-1 TCP连接建立过程的三个报文信息【如果有多条，全部列出】

| 字段名称    | 第1条报文 | 第2条报文 | 第3条报文 |
| ----------- | --------- | --------- | --------- |
| 报文序号NO. | 554       | 555       | 556       |
| Seq #       | 0         | 0         | 1         |
| Ack #       | 0         | 1         | 1         |
| ACK Flag    | 0         | 1         | 1         |
| SYN Flag    | 1         | 1         | 0         |

表3-2 TCP连接撤销的四个报文信息

![image-20220314093921050](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314093921050.png)

| 字段名称        | 首条报文 | 二条报文 | 三条报文 | 四条报文 |
| --------------- | -------- | -------- | -------- | -------- |
| 报文捕获序号NO. | 1406     | 1407     | 1408     |          |
| Seq #           | 557559   | 8962     | 557560   |          |
| Ack #           | 8962     | 557560   | 8963     |          |
| ACK             | 1        | 1        | 1        |          |
| FIN             | 1        | 1        | 0        |          |

图中填写的均为相对序号。可以看到TCP连接撤销的四个报文信息仅仅抓到了三个，这是因为服务器返回客户端的ACK报文和服务器主动提出的FIN报文合为一个报文发送。

### 步骤5：

分析TCP数据传送阶段的报文，分析其错误恢复和流量控制机制，并填表。【注：出现明显的流量控制的地方，Wireshark会有[TCP Window Full]标记。如果没有观察到明显的流量控制过程，可以再单独设计实验测试。比如编程设计接收端缓慢接收数据。】

分析TCP数据传送阶段的错误恢复机制：

![img](https://gitee.com/Hijack8/tc/raw/master/img2/5db6fd214669e765c10620a59e5cbcdfe5e73148)

可以看到序号为723的报文的seq号为590999，然而服务器端连585239都没有收到，所以说进行了重传。

尝试许多次，始终无法抓到[window full]报文，于是仅仅对于普通的流量控制过程进行简单分析。

![img](https://gitee.com/Hijack8/tc/raw/master/img2/d1485ef1c2cb3a5a14f2bf35a5be5c6546bdcb0c)

表3-3 记录TCP数据传送阶段的报文

| 报文序号 | 报文种类  (数据/确认) | 序号字段Seq Number | 确认号Ack Number | 数据长度 | 确认到哪条报文（填序号） | 窗口大小 |
| -------- | --------------------- | ------------------ | ---------------- | -------- | ------------------------ | -------- |
| 41       | 数据                  | 1                  | 1                | 84       |                          | 516      |
| 42       | 确认                  | 1                  | 85               | 68       | 41                       | 258      |
| 43       | 数据                  | 85                 | 69               | 1440     | 42                       | 516      |
| 44       | 数据                  | 1525               | 69               | 1440     | 42                       | 516      |
| 45       | 数据                  | 2965               | 69               | 1440     | 42                       | 516      |
| 46       | 数据                  | 4405               | 69               | 1440     | 42                       | 516      |
| 47       | 数据                  | 5845               | 69               | 1440     | 42                       | 516      |
| 48       | 数据                  | 7285               | 69               | 1440     | 42                       | 516      |
| 49       | 数据                  | 8725               | 69               | 1440     | 42                       | 516      |
| 50       | 数据                  | 10165              | 69               | 1440     | 42                       | 516      |
| 51       | 数据                  | 11605              | 69               | 1440     | 42                       | 516      |
| 54       | 确认                  | 69                 | 2965             | 0        | 44                       | 304      |

 上表可以看到服务器的Window字段发生了变化，由开始的win = 258变到win = 304，这就是服务器端的流量控制的过程。

通过wireshark的统计分析，可以看到实际的流量控制非常复杂，接收窗口在不断变化：

![image-20220314110010296](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314110010296.png)

### 步骤6、

分析客户机和服务器两边各自捕获到的分组，**分析整个TCP流**，估计双方的RTT，重传率和重传流量，平均传输速度等参数。

RTT即是一个报文从发出到接收到他的应答报文所用的总时间，可以直接使用wireshark进行分析。

在过滤器中加入一句话:

```
&& tcp.analysis.ack_rtt
```

即可以在报文中自动出现计算好的rtt的值。

在客户端我们分析：

![image-20220314145958534](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314145958534.png)

发现客户端对服务器发送消息的rtt的值均为0.027s左右。

在服务器端我们分析

![image-20220314150639311](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314150639311.png)

发现服务器对客户端回复消息的rtt值为0,000005s左右。

此外发现本次传输文件过程中没有任何重传现象，于是尝试再重新传一个文件进行抓包处理：

![image-20220314152254189](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314152254189.png)

发现有许多重传数据包。

尝试计算总数据包的数量：
$$
数据包数量 = \frac{文件大小}{MSS大小} = \frac{533144B}{1440B} = 370.23个 = 371个
$$
总共有371个数据包传送，重传数据包有136个，所以重传率为：
$$
重传率 = \frac{136}{371} = 36.66\%
$$
重传流量为：
$$
重传流量 = 136\times 1440B= 191.25KB
$$
起始时间：

![image-20220314152943206](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314152943206.png)

结束时间：

![image-20220314153115739](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314153115739.png)

总时间：
$$
time = 28.213177-21.204995 s=7.008182s
$$
平均传输速度为：
$$
v = \frac{size}{time} = \frac{533144B}{7.008182s}= 76163.43Bps
$$

### 步骤7、

分析整个TCP流的拥塞控制，找到拥塞控制的几个典型过程（即慢启动、快速重传、拥塞避免，快速恢复），计算各个时期发送数据平均传输速度。

首先观察一下传输开始阶段的数据包传送个数：

![image-20220314104631761](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314104631761.png)

可以看出初始阶段No752到No762均为客户端传送的数据包，一共11个，但是分析服务器端的ACK报文可以发现，服务器端的ACK在第一次传输阶段ACK序号仅仅到16955，也就是说服务器端仅仅对于No761进行了确认，并没有对No762进行确认，由此我们得出第一个阶段服务器通过拥塞控制接收了10个报文，最后的第11个报文虽然也接收了但是却在下一阶段进行确认。

![image-20220314105436452](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314105436452.png)

在下一阶段可以看出连续传输了二十条报文，即先以cwnd = 10 起始，然后窗口乘2，因此基本符合拥塞控制中慢启动的特征。

通过统计分析也可以看出慢启动的过程：
![image-20220314111159521](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314111159521.png)

可以看到刚开始启动的过程中连续发送的数据包个数较少，慢慢才会增大。

### 步骤8、

如果拥塞控制的相关过程不明显，请设计合适的方法再次测试。

### 步骤9、

完成其他可选的实验步骤。

 查看linux系统的cwnd可以通过：

```
cat /usr/src/linux-headers-5.13.0-30-generic/include/net/tcp.h
```

![image-20220314160242852](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314160242852.png)

可以看到初始cwnd为10。

**经过我们的上述实验也可以证明这个初始cwnd。**

查看windows系统的初始cwnd的值：

```
netsh interface tcp show supplemental
```

![image-20220314160632509](https://gitee.com/Hijack8/tc/raw/master/img2/image-20220314160632509.png)

## 六、 互动讨论主题

1）TCP的流量控制和拥塞控制有什么不同？

流量控制是接收方对发送方的控制，接收方控制报文中window字段的大小来控制接收方发送报文的数量，流量控制是为了防止接收方接收缓冲区不足而存在的机制。

拥塞控制是发送方主动进行的，拥塞控制是为了控制一个RTT内最多发送的数据包数量，是为了防止过多的数据包进入到网络之中。

2） TCP的流量控制是哪一方（接收、发送）来主导的？什么情况下会发生流量控制？

发送方，流量控制是数据传输过程中时刻进行的，通过接收方回复的报文，使得发送方维护一个接收窗口，随着这个接收窗口的变化来进行控制数据的发送。

3）讨论传输层与其上下相邻层的关系；

传输层是一个端到端的层，传输层的报文要被封装为IP报文进行传输，传输层的主要协议有TCP和UDP协议，TCP给予可靠的面向连接服务，UDP给予不可靠服务，二者都需要封装上源IP地址、目的IP地址进行传输，由网络层进行具体的IP地址转发。

传输层与应用层的关系：传输层为应用层提供服务，应用层可以选择TCP或UDP进行传输，应用层会选择具体的传输层端口号进行传输数据，例如http选择的80端口，应用层的数据也是需要封装为tcp数据进行端到端传输的。

4）讨论TCP协议在传输实时语音流方面的优缺点。

TCP传输数据准确，但是比较UDP来说速度较慢。

 

 

 